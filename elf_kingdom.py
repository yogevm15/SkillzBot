# Generated by Haxe 3.4.7
# coding: utf-8

from __future__ import division
from __future__ import absolute_import
import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import inspect as python_lib_Inspect
import random as python_lib_Random
import re as python_lib_Re
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO
from itertools import imap
from itertools import ifilter


class _hx_AnonObject(object):
    def __init__(self, fields):
        self.__dict__ = fields


_hx_classes = {}


class Enum(object):
    _hx_class_name = u"Enum"
    __slots__ = (u"tag", u"index", u"params")
    _hx_fields = [u"tag", u"index", u"params"]
    _hx_methods = [u"__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + u"(") + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in _this]))) + u")")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes[u"Enum"] = Enum


class Api(object):
    _hx_class_name = u"Api"
    __slots__ = ()
    _hx_statics = [u"collectDefines", u"isBaseObject"]

    @staticmethod
    def collectDefines():
        pass

    @staticmethod
    def isBaseObject(cls):
        if (cls.name == u"BaseObject"):
            return True
        if (cls.superClass is None):
            return False
        superclass = cls.superClass.t.get()
        if (superclass.name == u"BaseObject"):
            return True
        return Api.isBaseObject(superclass)
Api._hx_class = Api
_hx_classes[u"Api"] = Api


class BaseObject(object):
    _hx_class_name = u"BaseObject"
    __slots__ = (u"type", u"_objectId")
    _hx_fields = [u"type", u"_objectId"]
    _hx_methods = [u"equals", u"hashCode", u"toString", u"__eq__", u"__ne__", u"__hash__", u"__repr__"]
    _hx_statics = [u"_game", u"__classNormalizedFields", u"_getNormalizedFields", u"__normalizeName"]

    def equals(self,other):
        if (not Std._hx_is(other,BaseObject)):
            return False
        BaseObject1 = other
        return (BaseObject1._objectId == self._objectId)

    def hashCode(self):
        return self._objectId

    def toString(self):
        return ((u"An object of type " + HxOverrides.stringOrNull(self.type)) + u".")

    def __eq__(self,other):
        return self.equals(other)

    def __ne__(self,other):
        return (not self.equals(other))

    def __hash__(self):
        return self.hashCode()

    def __repr__(self):
        return self.toString()
    _game = None

    @staticmethod
    def _getNormalizedFields(object,objectType):
        if (not (objectType in BaseObject._hx___classNormalizedFields.h)):
            normalizedFieldsMap = haxe_ds_StringMap()
            wantedClass = Type.getClass(object)
            _g = 0
            _g1 = python_Boot.getInstanceFields(wantedClass)
            while (_g < len(_g1)):
                instanceField = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                key = BaseObject._hx___normalizeName(instanceField)
                normalizedFieldsMap.h[key] = instanceField
            BaseObject._hx___classNormalizedFields.h[objectType] = normalizedFieldsMap
        return BaseObject._hx___classNormalizedFields.h.get(objectType,None)

    @staticmethod
    def _hx___normalizeName(name):
        snakeCaseRegex = EReg(u"([A-Z])",u"g")
        snakeCaseName = snakeCaseRegex.replace(name,u"_$1").lower()
        precedingDelimiterRemovalRegex = EReg(u"_*([a-z_]*)",u"g")
        return precedingDelimiterRemovalRegex.replace(snakeCaseName,u"$1")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.type = None
        _hx_o._objectId = None
BaseObject._hx_class = BaseObject
_hx_classes[u"BaseObject"] = BaseObject


class MapObject(BaseObject):
    _hx_class_name = u"MapObject"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = [u"get_location", u"distance", u"in_range", u"in_map"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = BaseObject


    def get_location(self):
        raise _HxException(u"Unimplemented!")

    def distance(self,other):
        return self.get_location().distance(other)

    def in_range(self,other,range):
        if ((self.get_location() is not None) and ((other.get_location() is not None))):
            return self.get_location().in_range(other.get_location(),range)
        else:
            return False

    def in_map(self):
        return BaseObject._game.in_map(self)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
MapObject._hx_class = MapObject
_hx_classes[u"MapObject"] = MapObject


class GameObject(MapObject):
    _hx_class_name = u"GameObject"
    __slots__ = (u"owner", u"id", u"unique_id", u"already_acted", u"location", u"current_health", u"max_health", u"initial_location")
    _hx_fields = [u"owner", u"id", u"unique_id", u"already_acted", u"location", u"current_health", u"max_health", u"initial_location"]
    _hx_methods = [u"equals", u"hashCode", u"toString", u"get_location"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = MapObject


    def equals(self,other):
        if (not Std._hx_is(other,GameObject)):
            return False
        gameObject = other
        return (gameObject.unique_id == self.unique_id)

    def hashCode(self):
        return self.unique_id

    def toString(self):
        return ((((((((u"{" + HxOverrides.stringOrNull(self.type)) + u" Id: ") + Std.string(self.id)) + u", Owner: ") + Std.string(self.owner.id)) + u", Loc: ") + Std.string(self.location)) + u"}")

    def get_location(self):
        return self.location

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.owner = None
        _hx_o.id = None
        _hx_o.unique_id = None
        _hx_o.already_acted = None
        _hx_o.location = None
        _hx_o.current_health = None
        _hx_o.max_health = None
        _hx_o.initial_location = None
GameObject._hx_class = GameObject
_hx_classes[u"GameObject"] = GameObject


class Building(GameObject):
    _hx_class_name = u"Building"
    __slots__ = (u"size",)
    _hx_fields = [u"size"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.size = None
Building._hx_class = Building
_hx_classes[u"Building"] = Building


class Castle(Building):
    _hx_class_name = u"Castle"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Building

Castle._hx_class = Castle
_hx_classes[u"Castle"] = Castle


class Class(object):
    _hx_class_name = u"Class"
Class._hx_class = Class
_hx_classes[u"Class"] = Class


class Creature(GameObject):
    _hx_class_name = u"Creature"
    __slots__ = (u"attack_range", u"attack_multiplier", u"summoner", u"summoning_duration", u"max_speed")
    _hx_fields = [u"attack_range", u"attack_multiplier", u"summoner", u"summoning_duration", u"max_speed"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    def __init__(self):
        self.summoning_duration = None
        self.summoner = None
        self.attack_multiplier = None
        self.attack_range = None
        self.max_speed = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.attack_range = None
        _hx_o.attack_multiplier = None
        _hx_o.summoner = None
        _hx_o.summoning_duration = None
        _hx_o.max_speed = None
Creature._hx_class = Creature
_hx_classes[u"Creature"] = Creature


class EReg(object):
    _hx_class_name = u"EReg"
    __slots__ = (u"pattern", u"_hx_global")
    _hx_fields = [u"pattern", u"global"]
    _hx_methods = [u"replace"]

    def __init__(self,r,opt):
        self._hx_global = False
        options = 0
        _g1 = 0
        _g = len(opt)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def replace(self,s,by):
        _this = by.split(u"$$")
        by1 = u"_hx_#repl#__".join([python_Boot.toString1(x1,u'') for x1 in _this])
        def _hx_local_0(x):
            res = by1
            g = x.groups()
            _g1 = 0
            _g = len(g)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = (u"$" + HxOverrides.stringOrNull(unicode((i + 1))))
                _this1 = (list(res) if ((delimiter == u"")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,u'') for x1 in _this1])
            _this2 = res.split(u"_hx_#repl#__")
            res = u"$".join([python_Boot.toString1(x1,u'') for x1 in _this2])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes[u"EReg"] = EReg


class Elf(GameObject):
    _hx_class_name = u"Elf"
    __slots__ = (u"attack_range", u"attack_multiplier", u"max_speed", u"is_building", u"currently_building", u"turns_to_build", u"current_spells", u"turns_to_revive", u"spawn_turns", u"invisible")
    _hx_fields = [u"attack_range", u"attack_multiplier", u"max_speed", u"is_building", u"currently_building", u"turns_to_build", u"current_spells", u"turns_to_revive", u"spawn_turns", u"invisible"]
    _hx_methods = [u"build_portal", u"can_build_portal", u"build_mana_fountain", u"can_build_mana_fountain", u"in_attack_range", u"attack", u"move_to", u"enoughManaToBuild", u"is_alive", u"can_cast_invisibility", u"cast_invisibility", u"can_cast_speed_up", u"cast_speed_up"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    def __init__(self):
        self.invisible = None
        self.spawn_turns = None
        self.turns_to_revive = None
        self.current_spells = None
        self.turns_to_build = None
        self.currently_building = None
        self.is_building = None
        self.attack_multiplier = None
        self.attack_range = None
        self.max_speed = 0

    def build_portal(self):
        orderArgs = u"\"product\": \"Portal\""
        BaseObject._game._addOrder(u"produce",self,orderArgs)
        if self.can_build_portal():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.portal_cost)
            _hx_local_0.mana
            self.is_building = True
            self.currently_building = u"Portal"

    def can_build_portal(self):
        if (self.is_alive() and self.enoughManaToBuild(BaseObject._game.portal_cost)):
            return BaseObject._game.can_build_portal_at(self.location)
        else:
            return False

    def build_mana_fountain(self):
        orderArgs = u"\"product\": \"ManaFountain\""
        BaseObject._game._addOrder(u"produce",self,orderArgs)
        if self.can_build_mana_fountain():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.mana_fountain_cost)
            _hx_local_0.mana
            self.is_building = True
            self.currently_building = u"ManaFountain"

    def can_build_mana_fountain(self):
        if (self.is_alive() and self.enoughManaToBuild(BaseObject._game.mana_fountain_cost)):
            return BaseObject._game.can_build_mana_fountain_at(self.location)
        else:
            return False

    def in_attack_range(self,mapObject):
        size = (Reflect.field(mapObject,u"size") if (hasattr(mapObject,((u"_hx_" + u"size") if ((u"size" in python_Boot.keywords)) else ((u"_hx_" + u"size") if (((((len(u"size") > 2) and ((ord(u"size"[0]) == 95))) and ((ord(u"size"[1]) == 95))) and ((ord(u"size"[(len(u"size") - 1)]) != 95)))) else u"size")))) else (Reflect.field(mapObject,u"Size") if (hasattr(mapObject,((u"_hx_" + u"Size") if ((u"Size" in python_Boot.keywords)) else ((u"_hx_" + u"Size") if (((((len(u"Size") > 2) and ((ord(u"Size"[0]) == 95))) and ((ord(u"Size"[1]) == 95))) and ((ord(u"Size"[(len(u"Size") - 1)]) != 95)))) else u"Size")))) else 0))
        return self.in_range(mapObject,(self.attack_range + size))

    def attack(self,target):
        BaseObject._game._addOrder(u"health_attack",self,(u"\"target\": " + Std.string(target.unique_id)))

    def move_to(self,destination):
        BaseObject._game._moveOrder(self,destination)

    def enoughManaToBuild(self,newBuildingCost):
        return (self.owner.mana >= newBuildingCost)

    def is_alive(self):
        return (self.turns_to_revive == 0)

    def can_cast_invisibility(self):
        if ((self.owner.mana >= BaseObject._game.invisibility_cost) and self.is_alive()):
            return (self.currently_building is None)
        else:
            return False

    def cast_invisibility(self):
        orderArgs = u"\"spell\": \"Invisibility\""
        BaseObject._game._addOrder(u"cast",self,orderArgs)
        if self.can_cast_invisibility():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.invisibility_cost)
            _hx_local_0.mana

    def can_cast_speed_up(self):
        if (self.owner.mana >= BaseObject._game.speed_up_cost):
            return self.is_alive()
        else:
            return False

    def cast_speed_up(self):
        orderArgs = u"\"spell\": \"SpeedUp\""
        BaseObject._game._addOrder(u"cast",self,orderArgs)
        if self.can_cast_speed_up():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.speed_up_cost)
            _hx_local_0.mana

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.attack_range = None
        _hx_o.attack_multiplier = None
        _hx_o.max_speed = None
        _hx_o.is_building = None
        _hx_o.currently_building = None
        _hx_o.turns_to_build = None
        _hx_o.current_spells = None
        _hx_o.turns_to_revive = None
        _hx_o.spawn_turns = None
        _hx_o.invisible = None
Elf._hx_class = Elf
_hx_classes[u"Elf"] = Elf


class IceTroll(Creature):
    _hx_class_name = u"IceTroll"
    __slots__ = (u"cost", u"suffocation_per_turn")
    _hx_fields = [u"cost", u"suffocation_per_turn"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Creature


    def __init__(self):
        self.suffocation_per_turn = None
        self.cost = None
        super(IceTroll, self).__init__()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cost = None
        _hx_o.suffocation_per_turn = None
IceTroll._hx_class = IceTroll
_hx_classes[u"IceTroll"] = IceTroll


class Spell(BaseObject):
    _hx_class_name = u"Spell"
    __slots__ = (u"expiration_turns", u"caster")
    _hx_fields = [u"expiration_turns", u"caster"]
    _hx_methods = [u"toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = BaseObject


    def toString(self):
        return ((((u"{" + HxOverrides.stringOrNull(self.type)) + u" , Caster: ") + Std.string(self.caster)) + u"}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.expiration_turns = None
        _hx_o.caster = None
Spell._hx_class = Spell
_hx_classes[u"Spell"] = Spell


class Invisibility(Spell):
    _hx_class_name = u"Invisibility"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Spell

Invisibility._hx_class = Invisibility
_hx_classes[u"Invisibility"] = Invisibility


class LavaGiant(Creature):
    _hx_class_name = u"LavaGiant"
    __slots__ = (u"cost", u"suffocation_per_turn")
    _hx_fields = [u"cost", u"suffocation_per_turn"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Creature


    def __init__(self):
        self.suffocation_per_turn = None
        self.cost = None
        super(LavaGiant, self).__init__()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cost = None
        _hx_o.suffocation_per_turn = None
LavaGiant._hx_class = LavaGiant
_hx_classes[u"LavaGiant"] = LavaGiant


class Location(MapObject):
    _hx_class_name = u"Location"
    __slots__ = (u"row", u"col")
    _hx_fields = [u"row", u"col"]
    _hx_methods = [u"get_location", u"equals", u"add", u"subtract", u"multiply", u"__add__", u"__sub__", u"__mul__", u"__rmul__", u"hashCode", u"toString", u"in_range", u"distance", u"towards"]
    _hx_statics = [u"_roundTowards"]
    _hx_interfaces = []
    _hx_super = MapObject


    def __init__(self,row,col):
        self.row = row
        self.col = col

    def get_location(self):
        return self

    def equals(self,other):
        if (not Std._hx_is(other,Location)):
            return False
        location = other
        if (self.row == location.row):
            return (self.col == location.col)
        else:
            return False

    def add(self,other):
        return Location((self.row + other.row),(self.col + other.col))

    def subtract(self,other):
        return Location((self.row - other.row),(self.col - other.col))

    def multiply(self,factor):
        final_row = (self.row * factor)
        x = (BaseObject._game.rows / 2)
        final_row1 = None
        try:
            final_row1 = int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            final_row1 = None
        final_row2 = Location._roundTowards(final_row,final_row1)
        final_col = (self.col * factor)
        x1 = (BaseObject._game.cols / 2)
        final_col1 = None
        try:
            final_col1 = int(x1)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            final_col1 = None
        final_col2 = Location._roundTowards(final_col,final_col1)
        return Location(final_row2,final_col2)

    def __add__(self,other):
        return self.add(other)

    def __sub__(self,other):
        return self.subtract(other)

    def __mul__(self,factor):
        return self.multiply(factor)

    def __rmul__(self,factor):
        return self.multiply(factor)

    def hashCode(self):
        x = ((0.5 * ((self.row + self.col))) * (((self.row + self.col) + 1)))
        tmp = None
        try:
            tmp = int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return (tmp + self.col)

    def toString(self):
        return ((((u"(" + Std.string(self.row)) + u", ") + Std.string(self.col)) + u")")

    def in_range(self,other,range):
        return (self.distance(other) <= range)

    def distance(self,other):
        loc = other.get_location()
        rowDistance = (self.row - loc.row)
        colDistance = (self.col - loc.col)
        v = ((rowDistance * rowDistance) + ((colDistance * colDistance)))
        x = Math.ceil((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        try:
            return int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    def towards(self,other,length):
        otherLocation = other.get_location()
        distance = self.distance(otherLocation)
        if ((distance <= length) or ((distance == 0))):
            return otherLocation
        vector_ratio = (length / distance)
        delta_row = (((otherLocation.row - self.row)) * vector_ratio)
        delta_col = (((otherLocation.col - self.col)) * vector_ratio)
        final_row = Location._roundTowards((self.row + delta_row),self.row)
        final_col = Location._roundTowards((self.col + delta_col),self.col)
        return Location(final_row,final_col)

    @staticmethod
    def _roundTowards(to_round,integer):
        if (to_round > integer):
            x = Math.floor(to_round)
            try:
                return int(x)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None
        elif (to_round < integer):
            x1 = Math.ceil(to_round)
            try:
                return int(x1)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                return None
        else:
            tmp = None
            try:
                tmp = int(to_round)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                tmp = None
            return tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.row = None
        _hx_o.col = None
Location._hx_class = Location
_hx_classes[u"Location"] = Location


class ManaFountain(Building):
    _hx_class_name = u"ManaFountain"
    __slots__ = (u"cost", u"mana_per_turn")
    _hx_fields = [u"cost", u"mana_per_turn"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Building


    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cost = None
        _hx_o.mana_per_turn = None
ManaFountain._hx_class = ManaFountain
_hx_classes[u"ManaFountain"] = ManaFountain

class _ObjectParser_PromiseType(Enum):
    __slots__ = ()
    _hx_class_name = u"_ObjectParser.PromiseType"
    _hx_constructs = [u"Assign", u"Update"]

    @staticmethod
    def Assign(field):
        return _ObjectParser_PromiseType(u"Assign", 0, [field])

    @staticmethod
    def Update(objects,insertionIndex):
        return _ObjectParser_PromiseType(u"Update", 1, [objects,insertionIndex])
_ObjectParser_PromiseType._hx_class = _ObjectParser_PromiseType
_hx_classes[u"_ObjectParser.PromiseType"] = _ObjectParser_PromiseType


class _ObjectParser_Promise(object):
    _hx_class_name = u"_ObjectParser.Promise"
    __slots__ = (u"instance", u"type")
    _hx_fields = [u"instance", u"type"]

    def __init__(self,instance,_hx_type):
        self.instance = instance
        self.type = _hx_type

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.instance = None
        _hx_o.type = None
_ObjectParser_Promise._hx_class = _ObjectParser_Promise
_hx_classes[u"_ObjectParser.Promise"] = _ObjectParser_Promise


class ObjectParser(object):
    _hx_class_name = u"ObjectParser"
    __slots__ = ()
    _hx_statics = [u"__loadVectorOfBaseObjects_SpeedUp", u"__loadVectorOfBaseObjects_Invisibility", u"__loadVectorOfBaseObjects_Spell", u"__loadVectorOfBaseObjects_Location", u"__loadVectorOfBaseObjects_Building", u"__loadVectorOfBaseObjects_ManaFountain", u"__loadVectorOfBaseObjects_Portal", u"__loadVectorOfBaseObjects_Castle", u"__loadVectorOfBaseObjects_Elf", u"__loadVectorOfBaseObjects_LavaGiant", u"__loadVectorOfBaseObjects_IceTroll", u"__loadVectorOfBaseObjects_Creature", u"__loadVectorOfBaseObjects_MapObject", u"__loadVectorOfBaseObjects_GameObject", u"__loadVectorOfBaseObjects_PirateGame", u"__loadVectorOfBaseObjects_Player", u"__loadVectorOfBaseObjects_BaseObject", u"__loadVectorOfBaseObjects_ObjectParser", u"__loadVectorOfBaseObjects_Api", u"__loadVectorBuiltins_Bool", u"__loadVectorBuiltins_String", u"__loadVectorBuiltins_Int", u"__submittedObjects", u"__submittedTemporaryObjects", u"__objectsWaitList", u"__currentNamespace", u"_nativeAPI", u"_parseTurn", u"__submitObject", u"__updateObjects", u"__loadObject", u"__loadFields", u"__loadVectorOfUnknownType", u"__addPromise", u"__fulfilPromise", u"__createEmptyInstance", u"__getField", u"__setField"]

    @staticmethod
    def _hx___loadVectorOfBaseObjects_SpeedUp(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Invisibility(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Spell(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Location(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Building(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_ManaFountain(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Portal(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Castle(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Elf(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_LavaGiant(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_IceTroll(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Creature(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_MapObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_GameObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_PirateGame(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Player(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_BaseObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_ObjectParser(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfBaseObjects_Api(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorBuiltins_Bool(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _hx___loadVectorBuiltins_String(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _hx___loadVectorBuiltins_Int(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.setField(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _parseTurn(game,objectsData):
        ObjectParser._hx___submitObject(game,False)
        ObjectParser._hx___submittedTemporaryObjects = haxe_ds_IntMap()
        _g = 0
        while (_g < len(objectsData)):
            obj = objectsData[_g]
            _g = (_g + 1)
            ObjectParser._hx___loadObject(obj)
        ObjectParser._hx___updateObjects()

    @staticmethod
    def _hx___submitObject(object,temporaryObject):
        if temporaryObject:
            ObjectParser._hx___submittedTemporaryObjects.set(object._objectId,object)
        else:
            ObjectParser._hx___submittedObjects.set(object._objectId,object)

    @staticmethod
    def _hx___updateObjects():
        _g = haxe_ds_IntMap()
        key = ObjectParser._hx___objectsWaitList.keys()
        while key.hasNext():
            key1 = key.next()
            _g.set(key1,ObjectParser._hx___objectsWaitList.h.get(key1,None))
        mapCopy = _g
        objectId = mapCopy.keys()
        while objectId.hasNext():
            objectId1 = objectId.next()
            object = ObjectParser._hx___submittedObjects.h.get(objectId1,None)
            if (object is None):
                object = ObjectParser._hx___submittedTemporaryObjects.h.get(objectId1,None)
            _g1 = 0
            _g2 = mapCopy.h.get(objectId1,None)
            while (_g1 < len(_g2)):
                promise = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                ObjectParser._hx___fulfilPromise(promise,object)
            ObjectParser._hx___objectsWaitList.remove(objectId1)

    @staticmethod
    def _hx___loadObject(data):
        objectId = data.get(u"object_id")
        _hx_type = data.get(u"type")
        temporaryObject = data.get(u"temporary_object")
        object = None
        if ((not (objectId in ObjectParser._hx___submittedObjects.h)) or temporaryObject):
            object = ObjectParser._hx___createEmptyInstance(_hx_type)
        else:
            object = ObjectParser._hx___submittedObjects.h.get(objectId,None)
        ObjectParser._hx___loadFields(object,_hx_type,data)
        ObjectParser._hx___submitObject(object,temporaryObject)

    @staticmethod
    def _hx___loadFields(object,objectType,initData):
        instanceNormalizedFields = BaseObject._getNormalizedFields(object,objectType)
        _g = 0
        _g1 = initData.keys()
        while (_g < len(_g1)):
            initField = _g1[_g]
            _g = (_g + 1)
            instanceField = instanceNormalizedFields.h.get(initField,None)
            if (instanceField is not None):
                initValue = initData.get(initField)
                otherObjectId = ObjectParser._nativeAPI.getField(initValue,u"object_id")
                if (otherObjectId is not None):
                    ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Assign(instanceField)))
                else:
                    listType = ObjectParser._nativeAPI.getField(initValue,u"list_type")
                    if (listType is not None):
                        initValueArray = ObjectParser._nativeAPI.getField(initValue,u"value")
                        ObjectParser._hx___loadVectorOfUnknownType(object,initValueArray,instanceField,listType)
                    else:
                        ObjectParser._nativeAPI.setField(object,instanceField,initValue)
            elif (initField != u"temporary_object"):
                raise _HxException((((((u"Unknown field during loading: " + Std.string(initField)) + u", of ") + Std.string(object)) + u". The normalized fields are: ") + HxOverrides.stringOrNull(instanceNormalizedFields.toString())))

    @staticmethod
    def _hx___loadVectorOfUnknownType(object,initValueArray,instanceField,listType):
        args = [object, initValueArray, instanceField]
        if (listType == u"int"):
            ObjectParser._hx___loadVectorBuiltins_Int(args,None)
        if (listType == u"str"):
            ObjectParser._hx___loadVectorBuiltins_String(args,None)
        if (listType == u"bool"):
            ObjectParser._hx___loadVectorBuiltins_Bool(args,None)
        elif (listType == u"Api"):
            ObjectParser._hx___loadVectorOfBaseObjects_Api(args,None)
        elif (listType == u"ObjectParser"):
            ObjectParser._hx___loadVectorOfBaseObjects_ObjectParser(args,None)
        elif (listType == u"BaseObject"):
            ObjectParser._hx___loadVectorOfBaseObjects_BaseObject(args,None)
        elif (listType == u"Player"):
            ObjectParser._hx___loadVectorOfBaseObjects_Player(args,None)
        elif (listType == u"PirateGame"):
            ObjectParser._hx___loadVectorOfBaseObjects_PirateGame(args,None)
        elif (listType == u"GameObject"):
            ObjectParser._hx___loadVectorOfBaseObjects_GameObject(args,None)
        elif (listType == u"MapObject"):
            ObjectParser._hx___loadVectorOfBaseObjects_MapObject(args,None)
        elif (listType == u"Creature"):
            ObjectParser._hx___loadVectorOfBaseObjects_Creature(args,None)
        elif (listType == u"IceTroll"):
            ObjectParser._hx___loadVectorOfBaseObjects_IceTroll(args,None)
        elif (listType == u"LavaGiant"):
            ObjectParser._hx___loadVectorOfBaseObjects_LavaGiant(args,None)
        elif (listType == u"Elf"):
            ObjectParser._hx___loadVectorOfBaseObjects_Elf(args,None)
        elif (listType == u"Castle"):
            ObjectParser._hx___loadVectorOfBaseObjects_Castle(args,None)
        elif (listType == u"Portal"):
            ObjectParser._hx___loadVectorOfBaseObjects_Portal(args,None)
        elif (listType == u"ManaFountain"):
            ObjectParser._hx___loadVectorOfBaseObjects_ManaFountain(args,None)
        elif (listType == u"Building"):
            ObjectParser._hx___loadVectorOfBaseObjects_Building(args,None)
        elif (listType == u"Location"):
            ObjectParser._hx___loadVectorOfBaseObjects_Location(args,None)
        elif (listType == u"Spell"):
            ObjectParser._hx___loadVectorOfBaseObjects_Spell(args,None)
        elif (listType == u"Invisibility"):
            ObjectParser._hx___loadVectorOfBaseObjects_Invisibility(args,None)
        elif (listType == u"SpeedUp"):
            ObjectParser._hx___loadVectorOfBaseObjects_SpeedUp(args,None)

    @staticmethod
    def _hx___addPromise(objectId,promise):
        if (not (objectId in ObjectParser._hx___objectsWaitList.h)):
            ObjectParser._hx___objectsWaitList.set(objectId,list())
        _this = ObjectParser._hx___objectsWaitList.h.get(objectId,None)
        _this.append(promise)

    @staticmethod
    def _hx___fulfilPromise(promise,promisedObject):
        _g = promise.type
        _g1 = _g.index
        if (_g1 == 0):
            field = _g.params[0]
            ObjectParser._nativeAPI.setField(promise.instance,field,promisedObject)
        elif (_g1 == 1):
            index = _g.params[1]
            objects = _g.params[0]
            val = promisedObject
            objects[index] = val
        else:
            pass

    @staticmethod
    def _hx___createEmptyInstance(className):
        if (ObjectParser._hx___currentNamespace is None):
            _this = Type.getClassName(BaseObject)
            currentClassName = _this.split(u".")
            if (len(currentClassName) != 0):
                currentClassName.pop()
            ObjectParser._hx___currentNamespace = u".".join([python_Boot.toString1(x1,u'') for x1 in currentClassName])
        newObject = None
        if (ObjectParser._hx___currentNamespace != u""):
            newObject = Type.createEmptyInstance(Type.resolveClass(((HxOverrides.stringOrNull(ObjectParser._hx___currentNamespace) + u".") + (u"null" if className is None else className))))
        else:
            newObject = Type.createEmptyInstance(Type.resolveClass(className))
        return newObject

    @staticmethod
    def _hx___getField(object,field):
        return ObjectParser._nativeAPI.getField(object,field)

    @staticmethod
    def _hx___setField(object,field,value):
        ObjectParser._nativeAPI.setField(object,field,value)
ObjectParser._hx_class = ObjectParser
_hx_classes[u"ObjectParser"] = ObjectParser


class Game(BaseObject):
    _hx_class_name = u"Game"
    __slots__ = (u"_hx___players", u"_hx___turnTime", u"_hx___turnStartTime", u"_hx___numPlayers", u"_hx___recoverErrors", u"_runnerFullStacktrace", u"max_points", u"max_turns", u"turn", u"_hx___me", u"_hx___enemies", u"_hx___orders", u"_hx___nativeAPI", u"_hx___orderLines", u"ice_troll_attack_range", u"ice_troll_attack_multiplier", u"lava_giant_attack_range", u"lava_giant_attack_multiplier", u"elf_attack_range", u"elf_attack_multiplier", u"lava_giant_max_health", u"ice_troll_max_health", u"castle_max_health", u"mana_fountain_max_health", u"elf_max_health", u"portal_max_health", u"castle_size", u"portal_size", u"mana_fountain_size", u"lava_giant_max_speed", u"ice_troll_max_speed", u"elf_max_speed", u"lava_giant_cost", u"lava_giant_summoning_duration", u"ice_troll_cost", u"ice_troll_summoning_duration", u"portal_cost", u"portal_building_duration", u"mana_fountain_cost", u"mana_fountain_building_duration", u"speed_up_cost", u"speed_up_expiration_turns", u"invisibility_cost", u"invisibility_expiration_turns", u"lava_giant_suffocation_per_turn", u"ice_troll_suffocation_per_turn", u"_hx___buildings", u"default_mana_per_turn", u"_hx___castles", u"rows", u"cols", u"elf_spawn_turns", u"_hx___portals", u"speed_up_multiplier", u"_hx___manaFountains", u"mana_fountain_mana_per_turn")
    _hx_fields = [u"__players", u"__turnTime", u"__turnStartTime", u"__numPlayers", u"__recoverErrors", u"_runnerFullStacktrace", u"max_points", u"max_turns", u"turn", u"__me", u"__enemies", u"__orders", u"__nativeAPI", u"__orderLines", u"ice_troll_attack_range", u"ice_troll_attack_multiplier", u"lava_giant_attack_range", u"lava_giant_attack_multiplier", u"elf_attack_range", u"elf_attack_multiplier", u"lava_giant_max_health", u"ice_troll_max_health", u"castle_max_health", u"mana_fountain_max_health", u"elf_max_health", u"portal_max_health", u"castle_size", u"portal_size", u"mana_fountain_size", u"lava_giant_max_speed", u"ice_troll_max_speed", u"elf_max_speed", u"lava_giant_cost", u"lava_giant_summoning_duration", u"ice_troll_cost", u"ice_troll_summoning_duration", u"portal_cost", u"portal_building_duration", u"mana_fountain_cost", u"mana_fountain_building_duration", u"speed_up_cost", u"speed_up_expiration_turns", u"invisibility_cost", u"invisibility_expiration_turns", u"lava_giant_suffocation_per_turn", u"ice_troll_suffocation_per_turn", u"__buildings", u"default_mana_per_turn", u"__castles", u"rows", u"cols", u"elf_spawn_turns", u"__portals", u"speed_up_multiplier", u"__manaFountains", u"mana_fountain_mana_per_turn"]
    _hx_methods = [u"__printIgnoredOrders", u"_nextTurn", u"_shouldRecoverErrors", u"isFilePosInBot", u"_addOrder", u"_addMoveOrder", u"_getActions", u"debug", u"get_myself", u"get_enemy", u"get_all_players", u"get_time_remaining", u"get_max_turn_time", u"can_build_portal_at", u"can_build_mana_fountain_at", u"get_all_buildings", u"canBuildInLocation", u"get_my_mana", u"get_enemy_mana", u"get_all_castles", u"get_my_castle", u"get_enemy_castle", u"in_map", u"get_all_living_elves", u"get_all_elves", u"get_my_living_elves", u"get_all_my_elves", u"get_enemy_living_elves", u"get_all_enemy_elves", u"get_all_portals", u"get_my_portals", u"get_enemy_portals", u"_moveOrder", u"get_my_creatures", u"get_enemy_creatures", u"get_all_mana_fountains", u"get_my_mana_fountains", u"get_enemy_mana_fountains", u"get_my_ice_trolls", u"get_enemy_ice_trolls", u"get_my_lava_giants", u"get_enemy_lava_giants"]
    _hx_statics = [u"__getObjectsOfOtherPlayers_ManaFountain", u"__getObjectsOfPlayer_ManaFountain", u"__getObjectsOfOtherPlayers_Portal", u"__getObjectsOfPlayer_Portal", u"__getObjectsOfOtherPlayers_Castle", u"__getObjectsOfPlayer_Castle"]
    _hx_interfaces = []
    _hx_super = BaseObject


    def __init__(self,nativeAPI):
        self.mana_fountain_mana_per_turn = None
        self._hx___manaFountains = None
        self.speed_up_multiplier = None
        self._hx___portals = None
        self._hx___castles = None
        self.default_mana_per_turn = None
        self._hx___buildings = None
        self.invisibility_expiration_turns = None
        self.invisibility_cost = None
        self.speed_up_expiration_turns = None
        self.speed_up_cost = None
        self.mana_fountain_building_duration = None
        self.mana_fountain_cost = None
        self.portal_building_duration = None
        self.portal_cost = None
        self.ice_troll_summoning_duration = None
        self.ice_troll_cost = None
        self.lava_giant_summoning_duration = None
        self.lava_giant_cost = None
        self.mana_fountain_size = None
        self.portal_size = None
        self.castle_size = None
        self.elf_attack_multiplier = None
        self.elf_attack_range = None
        self.lava_giant_attack_multiplier = None
        self.lava_giant_attack_range = None
        self.ice_troll_attack_multiplier = None
        self.ice_troll_attack_range = None
        self._hx___enemies = None
        self._hx___me = None
        self._hx___players = None
        self.elf_spawn_turns = 0
        self.cols = 0
        self.rows = 0
        self.ice_troll_suffocation_per_turn = 0
        self.lava_giant_suffocation_per_turn = 0
        self.elf_max_speed = 0
        self.ice_troll_max_speed = 0
        self.lava_giant_max_speed = 0
        self.portal_max_health = 0
        self.elf_max_health = 0
        self.mana_fountain_max_health = 0
        self.castle_max_health = 0
        self.ice_troll_max_health = 0
        self.lava_giant_max_health = 0
        self._hx___orderLines = haxe_ds_ObjectMap()
        self._hx___orders = list()
        self.turn = 0
        self.max_turns = 0
        self.max_points = 0
        self._runnerFullStacktrace = False
        self._hx___recoverErrors = True
        self._hx___numPlayers = 0
        self._hx___turnStartTime = 0
        self._hx___turnTime = 0
        self._hx___nativeAPI = nativeAPI
        self._objectId = 0
        ObjectParser._nativeAPI = nativeAPI
        BaseObject._game = self

    def _hx___printIgnoredOrders(self):
        obj = self._hx___orderLines.keys()
        while obj.hasNext():
            obj1 = obj.next()
            dataArray = self._hx___orderLines.h.get(obj1,None)
            if (len(dataArray) >= 2):
                stringData = u""
                _g = 0
                while (_g < len(dataArray)):
                    data = (dataArray[_g] if _g >= 0 and _g < len(dataArray) else None)
                    _g = (_g + 1)
                    stringData = ((u"null" if stringData is None else stringData) + HxOverrides.stringOrNull(((((u"\nfile : " + HxOverrides.stringOrNull(data.file)) + u" line : ") + Std.string(data.line)))))
                self._hx___nativeAPI.writeLine((((u"All orders of " + Std.string(obj1)) + u" are ignored \nbecause it acted multiple times.\nActed at : ") + (u"null" if stringData is None else stringData)))

    def _nextTurn(self,objectsData):
        self._hx___turnStartTime = self._hx___nativeAPI.getCurrentTime()
        self._hx___orders = list()
        self._hx___printIgnoredOrders()
        self._hx___orderLines = haxe_ds_ObjectMap()
        ObjectParser._parseTurn(self,objectsData)

    def _shouldRecoverErrors(self):
        return self._hx___recoverErrors

    def isFilePosInBot(self,method,file):
        if (file is not None):
            return (file.find(u"lib") < 0)
        else:
            return False

    def _addOrder(self,orderType,actor,args = u""):
        if (args is None):
            args = u""
        order = ((((((u"{\"order_type\": \"" + (u"null" if orderType is None else orderType)) + u"\", \"actor\": ") + Std.string(actor.unique_id)) + u", \"order_args\": {") + (u"null" if args is None else args)) + u"}}")
        _this = self._hx___orders
        _this.append(order)
        cs = haxe_CallStack.callStack()
        _g = 0
        while (_g < len(cs)):
            item = (cs[_g] if _g >= 0 and _g < len(cs) else None)
            _g = (_g + 1)
            if (item.index == 2):
                line = item.params[2]
                file = item.params[1]
                method = item.params[0]
                if self.isFilePosInBot(method,file):
                    if (not self._hx___orderLines.exists(actor)):
                        this1 = self._hx___orderLines
                        v = list()
                        this1.set(actor,v)
                    fileName = HxString.substr(file,(file.rfind(u"/", 0, len(file)) + 1),None)
                    _this1 = self._hx___orderLines.get(actor)
                    _this1.append(_hx_AnonObject({u'file': fileName, u'line': line}))
                    actor.already_acted = True
                    break

    def _addMoveOrder(self,order,actor,dest):
        orderArgs = ((((u"\"destination\": [" + Std.string(dest.get_location().row)) + u", ") + Std.string(dest.get_location().col)) + u"]")
        self._addOrder(order,actor,orderArgs)

    def _getActions(self):
        self._hx___nativeAPI.writeLine(u"\nBOT_DEBUG_END_FLAG_FOR_ENGINE_USAGE")
        _this = self._hx___orders
        return ((u"{\"orders\": [" + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in _this]))) + u"]}")

    def debug(self,arg):
        self._hx___nativeAPI.writeLine(arg)

    def get_myself(self):
        return self._hx___me

    def get_enemy(self):
        return self._hx___enemies[0]

    def get_all_players(self):
        this1 = self._hx___players
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_time_remaining(self):
        return (self._hx___turnTime - ((self._hx___nativeAPI.getCurrentTime() - self._hx___turnStartTime)))

    def get_max_turn_time(self):
        return self._hx___turnTime

    def can_build_portal_at(self,location):
        return self.canBuildInLocation(BaseObject._game.portal_size,location)

    def can_build_mana_fountain_at(self,location):
        return self.canBuildInLocation(BaseObject._game.mana_fountain_size,location)

    def get_all_buildings(self):
        this1 = self._hx___buildings
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def canBuildInLocation(self,newBuildingSize,location):
        if (not location.in_map()):
            return False
        _g = 0
        _g1 = BaseObject._game.get_all_buildings()
        while (_g < len(_g1)):
            building = _g1[_g]
            _g = (_g + 1)
            if location.in_range(building,(newBuildingSize + building.size)):
                return False
        if (((((location.col - newBuildingSize) < 0) or (((location.col + newBuildingSize) > self.cols))) or (((location.row - newBuildingSize) < 0))) or (((location.row + newBuildingSize) > self.rows))):
            return False
        _g2 = 0
        _g11 = BaseObject._game.get_all_living_elves()
        while (_g2 < len(_g11)):
            elf = _g11[_g2]
            _g2 = (_g2 + 1)
            if elf.is_building:
                territoryRange = 0
                if (elf.currently_building == u"Portal"):
                    territoryRange = BaseObject._game.portal_size
                elif (elf.currently_building == u"ManaFountain"):
                    territoryRange = BaseObject._game.mana_fountain_size
                if location.in_range(elf,(territoryRange + newBuildingSize)):
                    return False
        return True

    def get_my_mana(self):
        return self._hx___me.mana

    def get_enemy_mana(self):
        return self._hx___enemies[0].mana

    def get_all_castles(self):
        this1 = self._hx___castles
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_castle(self):
        castles = Game._hx___getObjectsOfPlayer_Castle(self._hx___castles,self._hx___me)
        if (len(castles) == 0):
            return None
        return castles[0]

    def get_enemy_castle(self):
        castles = Game._hx___getObjectsOfOtherPlayers_Castle(self._hx___castles,self._hx___me)
        if (len(castles) == 0):
            return None
        return castles[0]

    def in_map(self,mapObject):
        location = mapObject.get_location()
        if ((location.row >= 0) and ((location.row < self.rows))):
            if (location.col >= 0):
                return (location.col < self.cols)
            else:
                return False
        else:
            return False

    def get_all_living_elves(self):
        elves = list()
        _g = 0
        _g1 = self.get_enemy_living_elves()
        while (_g < len(_g1)):
            elf = _g1[_g]
            _g = (_g + 1)
            elves.append(elf)
        _g2 = 0
        _g11 = self.get_my_living_elves()
        while (_g2 < len(_g11)):
            elf1 = _g11[_g2]
            _g2 = (_g2 + 1)
            elves.append(elf1)
        return list(elves)

    def get_all_elves(self):
        elves = list()
        _g = 0
        _g1 = self.get_all_enemy_elves()
        while (_g < len(_g1)):
            elf = _g1[_g]
            _g = (_g + 1)
            elves.append(elf)
        _g2 = 0
        _g11 = self.get_all_my_elves()
        while (_g2 < len(_g11)):
            elf1 = _g11[_g2]
            _g2 = (_g2 + 1)
            elves.append(elf1)
        return list(elves)

    def get_my_living_elves(self):
        this1 = self._hx___me.living_elves
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_all_my_elves(self):
        this1 = self._hx___me.all_elves
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_enemy_living_elves(self):
        elves = list()
        _g = 0
        _g1 = self._hx___enemies
        while (_g < len(_g1)):
            enemy_player = _g1[_g]
            _g = (_g + 1)
            _g2 = 0
            _g3 = enemy_player.living_elves
            while (_g2 < len(_g3)):
                obj = _g3[_g2]
                _g2 = (_g2 + 1)
                elves.append(obj)
        return list(elves)

    def get_all_enemy_elves(self):
        elves = list()
        _g = 0
        _g1 = self._hx___enemies
        while (_g < len(_g1)):
            enemy_player = _g1[_g]
            _g = (_g + 1)
            _g2 = 0
            _g3 = enemy_player.all_elves
            while (_g2 < len(_g3)):
                obj = _g3[_g2]
                _g2 = (_g2 + 1)
                elves.append(obj)
        return list(elves)

    def get_all_portals(self):
        this1 = self._hx___portals
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_portals(self):
        return Game._hx___getObjectsOfPlayer_Portal(self._hx___portals,self._hx___me)

    def get_enemy_portals(self):
        return Game._hx___getObjectsOfOtherPlayers_Portal(self._hx___portals,self._hx___me)

    def _moveOrder(self,mover,destination):
        BaseObject._game._addMoveOrder(u"vectoric_per_actor_move",mover,destination)

    def get_my_creatures(self):
        this1 = self._hx___me.creatures
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_enemy_creatures(self):
        this1 = self._hx___enemies[0].creatures
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_all_mana_fountains(self):
        this1 = self._hx___manaFountains
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_mana_fountains(self):
        return Game._hx___getObjectsOfPlayer_ManaFountain(self._hx___manaFountains,self._hx___me)

    def get_enemy_mana_fountains(self):
        return Game._hx___getObjectsOfOtherPlayers_ManaFountain(self._hx___manaFountains,self._hx___me)

    def get_my_ice_trolls(self):
        this1 = self._hx___me.ice_trolls
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_enemy_ice_trolls(self):
        this1 = self._hx___enemies[0].ice_trolls
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_lava_giants(self):
        this1 = self._hx___me.lava_giants
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_enemy_lava_giants(self):
        this1 = self._hx___enemies[0].lava_giants
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    @staticmethod
    def _hx___getObjectsOfOtherPlayers_ManaFountain(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner != player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfPlayer_ManaFountain(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner == player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfOtherPlayers_Portal(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner != player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfPlayer_Portal(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner == player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfOtherPlayers_Castle(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner != player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfPlayer_Castle(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner == player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___players = None
        _hx_o._hx___turnTime = None
        _hx_o._hx___turnStartTime = None
        _hx_o._hx___numPlayers = None
        _hx_o._hx___recoverErrors = None
        _hx_o._runnerFullStacktrace = None
        _hx_o.max_points = None
        _hx_o.max_turns = None
        _hx_o.turn = None
        _hx_o._hx___me = None
        _hx_o._hx___enemies = None
        _hx_o._hx___orders = None
        _hx_o._hx___nativeAPI = None
        _hx_o._hx___orderLines = None
        _hx_o.ice_troll_attack_range = None
        _hx_o.ice_troll_attack_multiplier = None
        _hx_o.lava_giant_attack_range = None
        _hx_o.lava_giant_attack_multiplier = None
        _hx_o.elf_attack_range = None
        _hx_o.elf_attack_multiplier = None
        _hx_o.lava_giant_max_health = None
        _hx_o.ice_troll_max_health = None
        _hx_o.castle_max_health = None
        _hx_o.mana_fountain_max_health = None
        _hx_o.elf_max_health = None
        _hx_o.portal_max_health = None
        _hx_o.castle_size = None
        _hx_o.portal_size = None
        _hx_o.mana_fountain_size = None
        _hx_o.lava_giant_max_speed = None
        _hx_o.ice_troll_max_speed = None
        _hx_o.elf_max_speed = None
        _hx_o.lava_giant_cost = None
        _hx_o.lava_giant_summoning_duration = None
        _hx_o.ice_troll_cost = None
        _hx_o.ice_troll_summoning_duration = None
        _hx_o.portal_cost = None
        _hx_o.portal_building_duration = None
        _hx_o.mana_fountain_cost = None
        _hx_o.mana_fountain_building_duration = None
        _hx_o.speed_up_cost = None
        _hx_o.speed_up_expiration_turns = None
        _hx_o.invisibility_cost = None
        _hx_o.invisibility_expiration_turns = None
        _hx_o.lava_giant_suffocation_per_turn = None
        _hx_o.ice_troll_suffocation_per_turn = None
        _hx_o._hx___buildings = None
        _hx_o.default_mana_per_turn = None
        _hx_o._hx___castles = None
        _hx_o.rows = None
        _hx_o.cols = None
        _hx_o.elf_spawn_turns = None
        _hx_o._hx___portals = None
        _hx_o.speed_up_multiplier = None
        _hx_o._hx___manaFountains = None
        _hx_o.mana_fountain_mana_per_turn = None
Game._hx_class = Game
_hx_classes[u"Game"] = Game


class Player(BaseObject):
    _hx_class_name = u"Player"
    __slots__ = (u"id", u"score", u"mana", u"mana_per_turn", u"all_elves", u"living_elves", u"creatures", u"ice_trolls", u"lava_giants")
    _hx_fields = [u"id", u"score", u"mana", u"mana_per_turn", u"all_elves", u"living_elves", u"creatures", u"ice_trolls", u"lava_giants"]
    _hx_methods = [u"equals", u"hashCode", u"toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = BaseObject


    def equals(self,other):
        if (not Std._hx_is(other,Player)):
            return False
        player = other
        return (player.id == self.id)

    def hashCode(self):
        return self.id

    def toString(self):
        return ((((u"{Player " + Std.string(self.id)) + u", score: ") + Std.string(self.score)) + u"}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.score = None
        _hx_o.mana = None
        _hx_o.mana_per_turn = None
        _hx_o.all_elves = None
        _hx_o.living_elves = None
        _hx_o.creatures = None
        _hx_o.ice_trolls = None
        _hx_o.lava_giants = None
Player._hx_class = Player
_hx_classes[u"Player"] = Player


class Portal(Building):
    _hx_class_name = u"Portal"
    __slots__ = (u"is_summoning", u"currently_summoning", u"turns_to_summon", u"cost")
    _hx_fields = [u"is_summoning", u"currently_summoning", u"turns_to_summon", u"cost"]
    _hx_methods = [u"summon_ice_troll", u"can_summon_ice_troll", u"summon_lava_giant", u"can_summon_lava_giant"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Building


    def summon_ice_troll(self):
        orderArgs = u"\"product\": \"IceTroll\""
        BaseObject._game._addOrder(u"produce",self,orderArgs)
        if self.can_summon_ice_troll():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.ice_troll_cost)
            _hx_local_0.mana
            self.is_summoning = True
            self.currently_summoning = u"IceTroll"

    def can_summon_ice_troll(self):
        if (self.owner.mana >= BaseObject._game.ice_troll_cost):
            return (not self.is_summoning)
        else:
            return False

    def summon_lava_giant(self):
        orderArgs = u"\"product\": \"LavaGiant\""
        BaseObject._game._addOrder(u"produce",self,orderArgs)
        if self.can_summon_lava_giant():
            _hx_local_0 = self.owner
            _hx_local_1 = _hx_local_0.mana
            _hx_local_0.mana = (_hx_local_1 - BaseObject._game.lava_giant_cost)
            _hx_local_0.mana
            self.is_summoning = True
            self.currently_summoning = u"LavaGiant"

    def can_summon_lava_giant(self):
        if (self.owner.mana >= BaseObject._game.lava_giant_cost):
            return (not self.is_summoning)
        else:
            return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.is_summoning = None
        _hx_o.currently_summoning = None
        _hx_o.turns_to_summon = None
        _hx_o.cost = None
Portal._hx_class = Portal
_hx_classes[u"Portal"] = Portal


class Reflect(object):
    _hx_class_name = u"Reflect"
    __slots__ = ()
    _hx_statics = [u"field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)
Reflect._hx_class = Reflect
_hx_classes[u"Reflect"] = Reflect


class SpeedUp(Spell):
    _hx_class_name = u"SpeedUp"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Spell

SpeedUp._hx_class = SpeedUp
_hx_classes[u"SpeedUp"] = SpeedUp


class Std(object):
    _hx_class_name = u"Std"
    __slots__ = ()
    _hx_statics = [u"is", u"string"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return True
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            if ((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))):
                tmp3 = (not python_lib_Math.isnan(f))
            else:
                tmp3 = False
        else:
            tmp3 = False
        if tmp3:
            tmp4 = None
            try:
                tmp4 = int(v)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp4 = None
            tmp2 = (v == tmp4)
        else:
            tmp2 = False
        if tmp2:
            tmp1 = (v <= 2147483647)
        else:
            tmp1 = False
        if tmp1:
            tmp = (v >= -2147483648)
        else:
            tmp = False
        if tmp:
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == unicode):
            return isinstance(v,unicode)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_class_name")) and (not hasattr(v,u"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp5 = None
        try:
            tmp5 = isinstance(v,t)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp5 = False
        if tmp5:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,u"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            loop1 = loop
            currentClass = v.__class__
            while (currentClass is not None):
                if loop1(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,u"")
Std._hx_class = Std
_hx_classes[u"Std"] = Std


class Float(object):
    _hx_class_name = u"Float"
Float._hx_class = Float
_hx_classes[u"Float"] = Float


class Int(object):
    _hx_class_name = u"Int"
Int._hx_class = Int
_hx_classes[u"Int"] = Int


class Bool(object):
    _hx_class_name = u"Bool"
Bool._hx_class = Bool
_hx_classes[u"Bool"] = Bool


class Dynamic(object):
    _hx_class_name = u"Dynamic"
Dynamic._hx_class = Dynamic
_hx_classes[u"Dynamic"] = Dynamic


class Type(object):
    _hx_class_name = u"Type"
    __slots__ = ()
    _hx_statics = [u"getClass", u"getSuperClass", u"getClassName", u"resolveClass", u"createEmptyInstance"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        if ((o is not None) and (((o == unicode) or python_lib_Inspect.isclass(o)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,u"_hx_class"):
            return o._hx_class
        if hasattr(o,u"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,u"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return u"Array"
            if (c == Math):
                return u"Math"
            if (c == unicode):
                return u"String"
            try:
                return c.__name__
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def resolveClass(name):
        if (name == u"Array"):
            return list
        if (name == u"Math"):
            return Math
        if (name == u"String"):
            return unicode
        cl = _hx_classes.get(name,None)
        if ((cl is None) or (not (((cl is not None) and (((cl == unicode) or python_lib_Inspect.isclass(cl))))))):
            return None
        return cl

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl1):
            sc = Type.getSuperClass(cl1)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl1,u"_hx_empty_init"):
                cl1._hx_empty_init(i)
        callInit = _hx_local_0
        callInit1 = callInit
        callInit1(cl)
        return i
Type._hx_class = Type
_hx_classes[u"Type"] = Type

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = u"haxe.StackItem"
    _hx_constructs = [u"CFunction", u"Module", u"FilePos", u"Method", u"LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem(u"Module", 1, [m])

    @staticmethod
    def FilePos(s,file,line):
        return haxe_StackItem(u"FilePos", 2, [s,file,line])

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem(u"Method", 3, [classname,method])

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem(u"LocalFunction", 4, [v])
haxe_StackItem.CFunction = haxe_StackItem(u"CFunction", 0, list())
haxe_StackItem._hx_class = haxe_StackItem
_hx_classes[u"haxe.StackItem"] = haxe_StackItem


class haxe_CallStack(object):
    _hx_class_name = u"haxe.CallStack"
    __slots__ = ()
    _hx_statics = [u"callStack"]

    @staticmethod
    def callStack():
        stack = []
        infos = python_lib_Traceback.extract_stack()
        if (len(infos) != 0):
            infos.pop()
        infos.reverse()
        _g = 0
        while (_g < len(infos)):
            elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
            _g = (_g + 1)
            x = haxe_StackItem.FilePos(None,elem[0],elem[1])
            stack.append(x)
        return stack
haxe_CallStack._hx_class = haxe_CallStack
_hx_classes[u"haxe.CallStack"] = haxe_CallStack


class haxe_IMap(object):
    _hx_class_name = u"haxe.IMap"
    __slots__ = ()
    _hx_methods = [u"get", u"set", u"exists", u"toString"]
haxe_IMap._hx_class = haxe_IMap
_hx_classes[u"haxe.IMap"] = haxe_IMap


class haxe_ds_IntMap(object):
    _hx_class_name = u"haxe.ds.IntMap"
    __slots__ = (u"h",)
    _hx_fields = [u"h"]
    _hx_methods = [u"set", u"get", u"exists", u"remove", u"keys", u"toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write(u"{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(u" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(u", ")
        s_b.write(u"}")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes[u"haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_ObjectMap(object):
    _hx_class_name = u"haxe.ds.ObjectMap"
    __slots__ = (u"h",)
    _hx_fields = [u"h"]
    _hx_methods = [u"set", u"get", u"exists", u"keys", u"toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write(u"{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(Std.string(i1)))
            s_b.write(u" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(u", ")
        s_b.write(u"}")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes[u"haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class haxe_ds_StringMap(object):
    _hx_class_name = u"haxe.ds.StringMap"
    __slots__ = (u"h",)
    _hx_fields = [u"h"]
    _hx_methods = [u"set", u"get", u"exists", u"keys", u"toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write(u"{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(u" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(u", ")
        s_b.write(u"}")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes[u"haxe.ds.StringMap"] = haxe_ds_StringMap


class haxe_ds__Vector_Vector_Impl_(object):
    _hx_class_name = u"haxe.ds._Vector.Vector_Impl_"
    __slots__ = ()
    _hx_statics = [u"blit"]
    length = None

    @staticmethod
    def blit(src,srcPos,dest,destPos,_hx_len):
        if (src is dest):
            if (srcPos < destPos):
                i = (srcPos + _hx_len)
                j = (destPos + _hx_len)
                _g1 = 0
                _g = _hx_len
                while (_g1 < _g):
                    k = _g1
                    _g1 = (_g1 + 1)
                    i = (i - 1)
                    j = (j - 1)
                    val = src[i]
                    src[j] = val
            elif (srcPos > destPos):
                i1 = srcPos
                j1 = destPos
                _g11 = 0
                _g2 = _hx_len
                while (_g11 < _g2):
                    k1 = _g11
                    _g11 = (_g11 + 1)
                    val1 = src[i1]
                    src[j1] = val1
                    i1 = (i1 + 1)
                    j1 = (j1 + 1)
        else:
            _g12 = 0
            _g3 = _hx_len
            while (_g12 < _g3):
                i2 = _g12
                _g12 = (_g12 + 1)
                val2 = src[(srcPos + i2)]
                dest[(destPos + i2)] = val2
haxe_ds__Vector_Vector_Impl_._hx_class = haxe_ds__Vector_Vector_Impl_
_hx_classes[u"haxe.ds._Vector.Vector_Impl_"] = haxe_ds__Vector_Vector_Impl_


class haxe_io_Eof(object):
    _hx_class_name = u"haxe.io.Eof"
    __slots__ = ()
    _hx_methods = [u"toString"]

    def __init__(self):
        pass

    def toString(self):
        return u"Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof
_hx_classes[u"haxe.io.Eof"] = haxe_io_Eof


class python_Boot(object):
    _hx_class_name = u"python.Boot"
    __slots__ = ()
    _hx_statics = [u"keywords", u"_add_dynamic", u"toString1", u"fields", u"simpleField", u"field", u"getInstanceFields", u"getSuperClass", u"getClassFields", u"prefixLength", u"unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,unicode) and isinstance(b,unicode)):
            return (a + b)
        if (isinstance(a,unicode) or isinstance(b,unicode)):
            return (python_Boot.toString1(a,u"") + python_Boot.toString1(b,u""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return u"null"
        if isinstance(o,unicode):
            return o
        if (s is None):
            s = u""
        if (len(s) >= 5):
            return u"<...>"
        if isinstance(o,bool):
            if o:
                return u"true"
            else:
                return u"false"
        if isinstance(o,int):
            return unicode(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return unicode(Math.floor((o + 0.5)))
                else:
                    return unicode(o)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return unicode(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = u"["
            s = ((u"null" if s is None else s) + u"\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = u""
                if (i > 0):
                    prefix = u","
                st = ((u"null" if st is None else st) + HxOverrides.stringOrNull((((u"null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = ((u"null" if st is None else st) + u"]")
            return st
        try:
            if hasattr(o,u"toString"):
                return o.toString()
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return u"<function>"
        if hasattr(o,u"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = (((u"" + (u"null" if f is None else f)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),((u"null" if s is None else s) + u"\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = ((u"{ " + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr]))) + u" }")
                except Exception, _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return u"{ ... }"
                if (toStr is None):
                    return u"{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = u""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = u""
                        if (i1 > 0):
                            prefix1 = u","
                        paramsStr = ((u"null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull((((u"null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + u"(") + (u"null" if paramsStr is None else paramsStr)) + u")")
                else:
                    return o2.tag
            if hasattr(o,u"_hx_class_name"):
                if (o.__class__.__name__ != u"type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = (((u"" + (u"null" if f1 is None else f1)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),((u"null" if s is None else s) + u"\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr1]))) + u" )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = (((u"" + (u"null" if f2 is None else f2)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),((u"null" if s is None else s) + u"\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = ((((u"#" + HxOverrides.stringOrNull(o._hx_class_name)) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr2]))) + u" )")
                    return toStr2
            if (o == unicode):
                return u"#String"
            if (o == list):
                return u"#Array"
            if callable(o):
                return u"function"
            try:
                if hasattr(o,u"__repr__"):
                    return o.__repr__()
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,u"__str__"):
                return o.__str__([])
            if hasattr(o,u"__name__"):
                return o.__name__
            return u"???"
        else:
            return unicode(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,u"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,u"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        field1 = field
        _hx_local_0 = len(field1)
        if (_hx_local_0 == 10):
            if (field1 == u"charCodeAt"):
                if isinstance(o,unicode):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == u"lastIndexOf"):
                if isinstance(o,unicode):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == u"toLowerCase"):
                if isinstance(o,unicode):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == u"toUpperCase"):
                if isinstance(o,unicode):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == u"substring"):
                if isinstance(o,unicode):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == u"copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field1 == u"join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,u'') for x1 in o])
                    return _hx_local_8
            elif (field1 == u"push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == u"sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == u"shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == u"slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == u"split"):
                if isinstance(o,unicode):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == u"indexOf"):
                if isinstance(o,unicode):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == u"reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == u"unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == u"map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == u"pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == u"iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == u"toString"):
                if isinstance(o,unicode):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == u"charAt"):
                if isinstance(o,unicode):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == u"concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == u"filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == u"insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == u"length"):
                if isinstance(o,unicode):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == u"remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == u"splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == u"substr"):
                if isinstance(o,unicode):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field2 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,u"_hx_fields")) else [])
        if hasattr(c,u"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,u"_hx_super"):
                return c._hx_super
            return None
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,u"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == u"_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes[u"python.Boot"] = python_Boot


class python_HaxeIterator(object):
    _hx_class_name = u"python.HaxeIterator"
    __slots__ = (u"it", u"x", u"has", u"checked")
    _hx_fields = [u"it", u"x", u"has", u"checked"]
    _hx_methods = [u"next", u"hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.next()
                self.has = True
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes[u"python.HaxeIterator"] = python_HaxeIterator


class python_internal_ArrayImpl(object):
    _hx_class_name = u"python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = [u"concat", u"iterator", u"indexOf", u"lastIndexOf", u"toString", u"pop", u"push", u"unshift", u"remove", u"shift", u"slice", u"sort", u"splice", u"map", u"filter", u"insert", u"reverse", u"_get"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return ((u"[" + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in x]))) + u"]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(imap(f,x))

    @staticmethod
    def filter(x,f):
        return list(ifilter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes[u"python.internal.ArrayImpl"] = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = u"_HxException"
    __slots__ = (u"val",)
    _hx_fields = [u"val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = unicode(val)
        super(_HxException, self).__init__(message)
        self.val = val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
_HxException._hx_class = _HxException
_hx_classes[u"_HxException"] = _HxException


class HxOverrides(object):
    _hx_class_name = u"HxOverrides"
    __slots__ = ()
    _hx_statics = [u"eq", u"stringOrNull"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return u"null"
        else:
            return s
HxOverrides._hx_class = HxOverrides
_hx_classes[u"HxOverrides"] = HxOverrides


class HxString(object):
    _hx_class_name = u"HxString"
    __slots__ = ()
    _hx_statics = [u"split", u"charCodeAt", u"charAt", u"lastIndexOf", u"toUpperCase", u"toLowerCase", u"indexOf", u"toString", u"substring", u"substr"]

    @staticmethod
    def split(s,d):
        if (d == u""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return u""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return u""
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes[u"HxString"] = HxString

Math.NEGATIVE_INFINITY = float(u"-inf")
Math.POSITIVE_INFINITY = float(u"inf")
Math.NaN = float(u"nan")
Math.PI = python_lib_Math.pi

BaseObject._hx___classNormalizedFields = haxe_ds_StringMap()
ObjectParser._hx___submittedObjects = haxe_ds_IntMap()
ObjectParser._hx___submittedTemporaryObjects = haxe_ds_IntMap()
ObjectParser._hx___objectsWaitList = haxe_ds_IntMap()
ObjectParser._hx___currentNamespace = None
ObjectParser._nativeAPI = None
python_Boot.keywords = set([u"and", u"del", u"from", u"not", u"with", u"as", u"elif", u"global", u"or", u"yield", u"assert", u"else", u"if", u"pass", u"None", u"break", u"except", u"import", u"raise", u"True", u"class", u"exec", u"in", u"return", u"False", u"continue", u"finally", u"is", u"try", u"def", u"for", u"lambda", u"while"])
python_Boot.prefixLength = len(u"_hx_")
__all__ = ['Api', 'ObjectParser', 'BaseObject', 'Player', 'Game', 'GameObject', 'MapObject', 'Creature', 'IceTroll', 'LavaGiant', 'Elf', 'Castle', 'Portal', 'ManaFountain', 'Building', 'Location', 'Spell', 'Invisibility', 'SpeedUp']
